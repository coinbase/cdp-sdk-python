# coding: utf-8

"""
    Coinbase Platform API

    This is the OpenAPI 3.0 specification for the Coinbase Platform APIs, used in conjunction with the Coinbase Platform SDKs.

    The version of the OpenAPI document: 0.0.1-alpha
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from cdp.client.models.transaction_log import TransactionLog
from typing import Optional, Set
from typing_extensions import Self

class TransactionReceipt(BaseModel):
    """
    The receipt of an onchain transaction's execution.
    """ # noqa: E501
    to: Optional[StrictStr] = Field(default=None, description="The address this transaction is to. This is null if the transaction was an init transaction, used to deploy a contract.")
    var_from: Optional[StrictStr] = Field(default=None, description="The address this transaction is from.", alias="from")
    contract_address: Optional[StrictStr] = Field(default=None, description="The EVM address of the smart contract. If this transaction has a null to address, it is an init transaction used to deploy a contract, in which case this is the address created by that contract.")
    transaction_index: Optional[StrictInt] = Field(default=None, description="The index of this transaction in the list of transactions included in the block this transaction was mined in.")
    type: Optional[StrictInt] = Field(default=None, description="The EIP-2718 transaction type. See https://eips.ethereum.org/EIPS/eip-2718 for more details.")
    logs_bloom: Optional[StrictStr] = Field(default=None, description="A bloom-filter, which includes all the addresses and topics included in any log in this transaction.")
    block_hash: Optional[StrictStr] = Field(default=None, description="The hash of the block at which the transaction was recorded.")
    transaction_hash: Optional[StrictStr] = Field(default=None, description="The hash of the onchain sponsored send transaction.")
    block_number: Optional[StrictInt] = Field(default=None, description="The block height (number) of the block that this transaction was included in.")
    confirmations: Optional[StrictInt] = Field(default=None, description="The number of blocks that have been mined since this transaction, including the actual block it was mined in.")
    root: Optional[StrictStr] = Field(default=None, description="The intermediate state root of a receipt.")
    cumulative_gas_used: Optional[StrictInt] = Field(default=None, description="For the block this transaction was included in, this is the sum of the gas used by each transaction in the ordered list of transactions up to (and including) this transaction.")
    byzantium: Optional[StrictBool] = Field(default=None, description="This is true if the block is in a post-Byzantium Hard Fork block.")
    status: StrictInt = Field(description="The status of a transaction is 1 if successful or 0 if it was reverted.")
    logs: List[TransactionLog]
    gas_used: Optional[StrictStr] = Field(default=None, description="The amount of gas actually used by this transaction.")
    effective_gas_price: Optional[StrictStr] = Field(default=None, description="The effective gas price the transaction was charged at.")
    __properties: ClassVar[List[str]] = ["to", "from", "contract_address", "transaction_index", "type", "logs_bloom", "block_hash", "transaction_hash", "block_number", "confirmations", "root", "cumulative_gas_used", "byzantium", "status", "logs", "gas_used", "effective_gas_price"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of TransactionReceipt from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in logs (list)
        _items = []
        if self.logs:
            for _item_logs in self.logs:
                if _item_logs:
                    _items.append(_item_logs.to_dict())
            _dict['logs'] = _items
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of TransactionReceipt from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "to": obj.get("to"),
            "from": obj.get("from"),
            "contract_address": obj.get("contract_address"),
            "transaction_index": obj.get("transaction_index"),
            "type": obj.get("type"),
            "logs_bloom": obj.get("logs_bloom"),
            "block_hash": obj.get("block_hash"),
            "transaction_hash": obj.get("transaction_hash"),
            "block_number": obj.get("block_number"),
            "confirmations": obj.get("confirmations"),
            "root": obj.get("root"),
            "cumulative_gas_used": obj.get("cumulative_gas_used"),
            "byzantium": obj.get("byzantium"),
            "status": obj.get("status"),
            "logs": [TransactionLog.from_dict(_item) for _item in obj["logs"]] if obj.get("logs") is not None else None,
            "gas_used": obj.get("gas_used"),
            "effective_gas_price": obj.get("effective_gas_price")
        })
        return _obj


